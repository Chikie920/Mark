---
title: PcNetwork_ChapterThree
date: 2021-10-24 16:54:51
tags: [Network]
coments: true
---

# 第3章-运输层



## 3.1-概述和运输层服务

运输层协议为运行在不同主机上的应用进程之间提供了逻辑通信，即两个进程似乎直接相连而不用考虑实现细节

运输层协议只实现在端系统上

发送进程将报文交给运输层，运输层加上首部封装成报文段，并交给网络层，网络层封装成数据报并经过下层的网络基础设施传递给接收端的网络层，接收端的网络层取出报文段上交给运输层，运输层将报文取出交给接收进程



### 3.1.1-运输层和网络层的关系

网络层提供了主机之间的逻辑通信，而运输层为运行在不同主机上的进程之间提供了逻辑通信

运输协议能够提供的服务常常受制于底层网络层协议的服务模型(IP)，网络层不能保证时延



### 3.1.2-因特网运输层概述

TCP(传输控制协议):可靠、面向连接的服务

UDP(用户数据报协议):不可靠、无连接的服务

网络层协议-网际协议(IP):尽力而为交付服务，不可靠数据传输



TCP提供流量控制、序号、确认、定时器等服务

拥塞控制：防止TCP连接中发送方以过高的速率传输，限制发送速率

UDP仅提供最低限度的服务：数据交付、差错检测服务



## 3.2-多路复用与多路分解

多路复用：将各进程套接字的输出数据封装首部传递给网络层

多路分解：将来自网络的数据交付给相应套接字



![network_3_1](/images/network_3_1.png)



一个进程能有一个或多个套接字，套接字是应用层与运输层的接口



运输层根据套接字的端口号进行识别，在每个报文段首部都有源端口号与目的端口号

周知端口号：0-1023(系统保留)

可供分配端口号：1024-65535



#### 无连接的多路复用与分解

通常，应用程序的客户端让运输层自动地（并且是透明地）分配端口号，而服务器端则分配一个特定的端口号



#### 面向连接的多路复用与分解

TCP套接字是由一个四元组（源IP地址, 源端口号, 目的IP 地址, 目的端口号）来标识的



## 3. 3-无连接运输：UDP

UDP仅提供多路复用、分解和少量的差错检测服务，应用层差不多直接与网络层(IP)打交道



有许多应用使用UDP的原因：

- 关于发送什么数据以及何时发送的应用层控制更为精细，实时应用通常要求最小的发送速率，不希望过分地延迟报文段的传送，且能
  容忍一些数据丢失， TCP 服务模型并不是特别适合这些应用的需要

- 无须连接建立，UDP 不会引入建立连接的时延
- 无连接状态
- 分组首部开销小，TCP首部一般为20字节，而UDP为8字节

- TCP 的拥塞控制会导致如因特网电话、视频会议之类的实时应用性能变得很差



![network_3_2](/images/network_3_2.png)



使用UDP也可以实现可靠数据传输，例如谷歌的**QUIC**协议，通过在应用层上建立机制，使UDP能提供可靠数据传输



### 3.3.1-UDP报文段结构

![network_3_3](/images/network_3_3.png)

UDP报文由首部+应用数据组成

首部有四个字段，每个有两个字节

长度字段：首部+数据的总长度



### 3.3.2-UDP检验和

发送时，UDP对报文段首部3个字段的3*16位比特位(不包括检验和字段)求和，发生溢出时回卷，最后进行反码运算得到检验和字段值

接收时，UDP计算四字段之和(采用回卷)，如果全是1，则无差错



端到端原则：UDP的差错检测采用了端到端原则，即在最开始与最后过程提供服务，因为仅在较底层次来实现可能没有价值或冗余



## 3.4-可靠数据传输原理

可靠数据传输的实现问题不仅在运输层出现，也会在链路层以及应用层出现

可靠数据传输协议：数据通过可靠信道传输，不会乱序、丢失或错误的服务的抽象

由于下层可能是不可靠的，所以实现困难

rdt-可靠数据传输 udt-不可靠数据传输

![network_3_4](/images/network_3_4.png)





### 3.4.1-构造可靠数据传输协议



#### 1. 经完全可靠信道的可靠数据传输：rdt1.0

底层信道完全可靠，不用担心数据差错

有限状态机(FSM):

初始状态用虚线表示，箭头表示状态的转移，横线上方表示事件，下方表示相应的动作，没有动作用^表示

![network_3_5](/images/network_3_5.png)



#### 2. 经具有比特差错信道的可靠数据传输：rdt2.0

底层信道更为实际的模型是分组中的比特可能受损的模型

肯定确认-ACK，表示成功接收

否定确认-NAK，表示需要重传

基于重传机制的可靠数据传输协议称为自动重传请求协议ARQ

功能：

- 差错检测
- 接收方反馈
- 重传



在等待接收方反馈时，发送方不能进行下一个事件(如发送新的分组)会一直等待，被称为**停等协议**

![network_3_6](/images/network_3_6.png)



rdt2.0缺陷：ACK或NAK可能会出错，造成发送端无法理解



#### rdt2.1

在数据分组中添加新字段(分组编号)

![network_3_7](/images/network_3_7.png)



![network_3_8](/images/network_3_8.png)



#### rdt2.2

不使用NAK，而是发送前一个分组的ACK，表示没有接收到

![network_3_9](/images/network_3_9.png)

![network_3_10](/images/network_3_10.png)



#### 3. 经具有比特差错的丢包信道的可靠数据传输：rdt3.0

假定除了比特受损外，底层信道还会丢包



引入新的重传机制：超时重传

当发送一个分组时开启一个定时器，当接收到该分组的确认后关闭，当超时时触发重传并启动该分组的定时器

到此我们得到了一个可靠的数据传输协议

![network_3_11](/images/network_3_11.png)





### 3.4.2-流水线可靠数据传输协议

rdt3.0是一个停等协议，必须等待已发送分组的ACK到达后才能继续发送，信道利用率非常低

利用率 = (L/R)/(RTT+L/R)    L/R为分组传输时间

解决方法：使用流水线技术，发送多个分组后再等待确认

解决流水线的分组丢失、损坏、乱序、时延过长有两种方法，都是使用重传机制

- 回退N步GBN
- 选择重传SR



### 3.4.3-回退N 步

允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但已发送未确认的分组不能超过窗口长度N，超过则需要等待确认

基序号：最早未确认分组的序号

下一个序号：最小未使用序号

如果序号字段长度为kbits，则表示范围为[0, 2^k-1]，大于则mod2^k

![network_3_12](/images/network_3_12.png)

![network_3_13](/images/network_3_13.png)

![network_3_14](/images/network_3_14.png)



GBN采用累计确认方式，表明接收方已经正确收到序号n及以前的所有分组

超时事件：发送方仅采用一个定时器，当收到ACK时且仍有未确认分组时重启定时器，当没有时关闭

当接收方收到的不是期待的分组时会丢弃



### 3.4.4-选择重传

GBN的重传机制可能会导致大量分组的重传

选择重传SR只会传输损坏、丢失或超时分组

接收方接收所有分组，失序分组将被缓存至其他分组到达，每个分组都有定时器

![network_3_15](/images/network_3_15.png)



![network_3_16](/images/network_3_16.png)



**窗口长度N比序号空间小1时，SR协议无法正常工作，N必须小于等于序号空间的一半**



## 3.5-面向连接的运输：TCP



### 3.5.1-TCP连接

TCP面向连接，在正式发送数据之前需相互握手，并建立一条逻辑连接，仅由两个端系统维护，中间的网络元素不参与因为没有运输层



三次握手：客户端发送特殊TCP报文段，服务器用一个特殊TCP报文段响应，客户端再用第三个特殊报文段响应，前两个报文段不承载"有效载荷"-不包括应用层数据，第三个可以



TCP有一个发送缓存，由三次握手建立，会不时取出数据并发送

最大报文段长度MSS：TCP能从缓存中取出数据的最大长度，为了保证封装成链路层帧的长度不超过最大值(最大传输单元，MTU)

MTU=1500，TCP/IP首部长度通常为40字节，则TCP可取出数据长度不超过1460字节

TCP连接的每一端都有发送、接收缓存



### 3.5.2-TCP报文段结构

由首部字段(一般为20bytes)+数据字段构成

![network_3_17](/images/network_3_17.png)

**首部介绍**

- 源、目的端口号被用于多路复用与分解(32bits)
- 序号字段对发送的报文段编号(32bits)
- 确认号字段为期待从另一端收到的相应序号的报文段(32bits)
- 接收窗口字段用于流量控制(16bits)
- 首部长度字段指示首部的长度(32bits)
- 选项字段为接收方协商最大报文段的长度(MSS)



#### 序号和确认号

**序号**

TCP根据传送的数据的字节流编号，而不是报文段

TCP隐式的对数据流中的每一个字节编号，分段后将每段第一个字节编号作为序号

![network_3_18](/images/network_3_18.png)

**确认号**

主机A填充进报文段的确认号是主机A期望从主机B收到的下一字节编号

TCP只确认该流中至第一个丢失字节为止的字节，所以被称为提供累计确认，一对TCP连接的双方均可随机的选择初始序号





### 3.5.3-往返时间的估计与超时



#### 1. 估计往返时问

使用样本RTT获得往返时间，TCP仅到某时刻做一次测量，只将第一次传输的报文段测量

TCP维持一个SampleRTT均值EstimateRTT

`EstimateRTT = (1-a)*EstimateRTT_Old+a*SampleRTT`    (a推荐值为0.125)



RTT偏差DevRTT估算SampleRTT偏离EstimateRTT的程度

`EstimateRTT = （1-b*DevRTT_Old+b*|SampleRTT-EstimateRTT|`   (b推荐值为0.25)



超时间隔`Timeoutlnterval = EstimateRTT +4*DevRTT`



每次获取新的SampleRTT，EstimateRTT、DevRTT与Timeoutlnterval都更新



### 3.5.4-可靠数据传输

看书比较好

