## 链表的简单介绍

链表由一个或多个相同的数据类型（结构体）的节点构成，每个节点在逻辑上相邻--通过结构体内的指针成员指向另一个节点，物理（内存）上可能并不相邻。



## 单链表的创建与操作



### 链表节点的声明

```c
typedef struct LinkNode {
    int data;
    struct LinkNode * next;
} LinkNode; //声明节点
```



### 为什么添加头节点

如果没有特别说明，均采用带头结点的单链表，在单链表中增加一个头节点的优点如下：

- 单链表中首结点的插入和删除操作与其他结点一致，无须进行特殊处理

- 无论单链表是否为空都有一个头结点，因此统一了空表和非空表的处理过程



### 头插法

```c
typedef struct LinkNode {
    int data;
    struct LinkNode * next;
} LinkNode; //创建节点

LinkNode *L = (LinkNode *) malloc(sizeof(LinkNode)); //创建头节点
LinkNode *p;
L->next = NULL;
int a[3] = {1, 2, 3};

for(int n = 0; n < 3; ++n){
    p = (LinkNode *) malloc(sizeof(LinkNode));
    p->data = a[n];
    p->next = L->next;
    L->next = p;
}
```



**示意图**



![单链表](D:\Chrome\单链表-头插法.png)



### 尾插法

```c
typedef struct LinkNode {
    int data;
    struct LinkNode * next;
} LinkNode; //创建节点

LinkNode *L = (LinkNode *) malloc(sizeof(LinkNode)); //创建头节点
LinkNode *p, *r;
L->next = NULL;
r = L;
int a[3] = {1, 2, 3};

for(int n = 0; n < 3; ++n){
    p = (LinkNode *) malloc(sizeof(LinkNode));
    p->next = r->next;
    r->next = p;
    r = p;
    p->data = a[n];
}
```



**示意图**



![单链表-尾插法](D:\Chrome\单链表-尾插法.png)



### 链表的创建、输出、查找、插入、节点删除



**头插法**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct LinkNode{
	int data;
	struct LinkNode * next;
} LinkNode;

void InsertLink(LinkNode *, int*);
void OutPut(LinkNode *, int);

int main(void)
{
    int a[4] = {15, 20, 25, 30};
	LinkNode *L = (LinkNode *) malloc(sizeof(LinkNode));
    L->next = NULL;
    InsertLink(L, a);
    OutPut(L, 4);
    return 0;
}

void InsertLink(LinkNode *L, int*a)
{
    for(int n = 0; n < 4; ++n){
        LinkNode *p = (LinkNode *) malloc(sizeof(LinkNode));
        p->data = a[n];
        p->next = L->next;
        L->next = p;
    }
}

void OutPut(LinkNode *L, int N)
{
	LinkNode *temp = L;
	for(int n = 0;n<N;++n){
		temp = temp->next;
		printf("%d ",temp->data);
	}
	printf("\n");
}
```



**尾插法**

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct LinkNode{
	int data;
	struct LinkNode * next;
} LinkNode;

void InsertLink(LinkNode *, int*);
void OutPut(LinkNode *, int);

int main(void)
{
    int a[4] = {15, 20, 25, 30};
	LinkNode *L = (LinkNode *) malloc(sizeof(LinkNode));
    L->next = NULL;
    InsertLink(L, a);
    OutPut(L, 4);
    return 0;
}

void InsertLink(LinkNode *L, int*a)
{
    LinkNode *r = L;
    for(int n = 0; n < 4; ++n){
        LinkNode *p = (LinkNode *) malloc(sizeof(LinkNode));
        r->next = p;
        r= p;
        p->data = a[n];
    }
}

void OutPut(LinkNode *L, int N)
{
	LinkNode *temp = L;
	for(int n = 0;n<N;++n){
		temp = temp->next;
		printf("%d ",temp->data);
	}
	printf("\n");
}
```



**链表的查找**

 这里只写关键实现代码(下同)

```c
int SerchNode(LinkNode *L)
{
    int i;
    int n = 1;
    LinkNode *p = L->next;//指向第一个节点，从第一个节点开始
    printf("输入要查找的节点: ");
    scanf("%d", &i);
    if(i<=0){
        return 1;
    }
    while(p&&n<i){ //定位到第i个元素
        ++n;
        p = p->next;
    }
    if(!p||n>i){
        return 1;
    }
    printf("%d\n", p->data);
    
    return 0;
}
```

​                                                                                                                  



**链表的插入**



```c
int InsertNode(LinkNode *L, int i, int data)
{
    int n = 1;
    LinkNode *p = L; //从头节点开始
    if(i<=0){
        return 1;
    }
    while(p&&n<i-1){ //定位到第i-1个节点，并确保后一个节点存在
        ++n;
        p = p->next;
    }
    if(!p||n>i-1){ //节点不存在
        return 1;
    }
    p->data = data;
    
    return 0;
}
```



**链表节点的删除**



```c
int DeleteNode(LinkNode *L, int i)
{
	int n = 1;
	LinkNode *p = L, *temp; //从头节点开始
	if(i<=0){
        return 1;
    }
	while(p&&n<i-1){ //定位到第i-1个节点，并确保后一个节点存在
        ++n;
        p = p->next;
    }
    temp = p->next;
    if(!temp){
        return 1;
    }
    p->next = temp->next;
    free(temp);
    
    return 0;
}
```

