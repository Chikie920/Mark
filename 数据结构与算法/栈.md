## 栈的简单介绍

栈是只能在一端进行插入或删除操作的线性表，允许操作的一端为栈顶，另一端为栈底。栈内的元素为先进后出，与链表的头插法类似。栈也有顺序与链式两种储存形式。



## 栈的创建与操作



### 顺序栈的声明

```c
typedef struct Stack {
    int data[MAXSIZE];
    int top;
} Stack;
```

可以看出与线性表类似，以成员二转换为数组下标进行数据的插入与访问等操作



### 顺序栈的创建

```c
#include <stdio.h>
#include <stdlib.h>

#define MAXSIZE 20

typedef struct Stack {
    int data[MAXSIZE];
    int top;
} Stack;

void InitStack(Stack *);
void CreateStack(Stack *, int *, int);
void OutPut(Stack *);

int main(void)
{
    int number[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    Stack *s = (Stack *) malloc(sizeof(Stack));
    InitStack(s);
    CreateStack(s, number, 10);
    OutPut(s);

    return 0;
}

void InitStack(Stack *s)
{
    s->top = 0;
}

void CreateStack(Stack *s, int *a, int N)
{
    for(int n = 0; n < N; ++n){
        s->data[s->top++] = a[n];
    }
}

void OutPut(Stack *s)
{
    for(int n = s->top-1; n >= 0; --n){
        printf("%d ", s->data[n]);
    }
    printf("\n");
}
```



**示意图**

![顺序栈创建](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\顺序栈创建.png)

我们**把`top`成员抽象为指针**，当有元素插入时，插入完后 `top`上移；同理当读取栈内元素时，`top`下移再读取。

主要是将`top`作为数组下标使用。



### 顺序栈的插入、删除等操作



**元素插入**

首先要判断是否为满

```c
int StackFull(Stack *s)
{
    return s->top == MAXSIZE;
}
```



```c
void PushStack(Stack *s, int num)
{
    if(StackFull(s)){
        return;
    }
    s->data[s->top++] = num;
}
```



### 链式栈声明

```c
typedef struct LinkNode {
    int data;
    struct LinkNode *next;
} LinkNode, *LinkStack;
```

可以看出与单链表结构相同，栈是先入后出的，所以使用**头插法**实现

其他操作参考链表，这里不再赘述。

