## BF算法

BF算法是暴力算法的英文简称，算法实现过程是让字串与目标串进行字符的依次比较，匹配时子串与目标串进行下一个字符的比较，当字符不匹配时，子串从头开始，而目标串从上一次开始的后一位字符开始比较，如此往复，直至子串或目标串比较完成。



**算法演示**

为了方便作图这里我们以子串的位移来等效目标串初始位的改变

![BF算法](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\BF算法.png)



**寻找失败位置与目标串下一初始比较位置的关系**

|           | 第一次比较 | 第二次比较 | 第三次比较 | 第四次比较 |
| --------- | ---------- | ---------- | ---------- | ---------- |
| P[i]      | P[1]       | P[2]       | P[2]       | P[3]       |
| S[j]      | S[1]       | S[1]       | S[0]       | S[3]       |
| 初始位[k] | 1          | 2          | 3          | Success    |

**k = i - j +1**



**BF算法实现**

```c
int BF(SString *p, char *s)
{
    int position; //用于回传匹配位置
    int i = 0;
    int j = 0;
    int p_len = p->length;
    int s_len = strlen(s);
    for(int n = 0; n < s_len;){ //当子串未匹配完时循环
        if(i == p_len+1){ //目标串匹配完
            return 0;
        }
        if(p->data[i] == s[j]){
            i++;
            j++;
            n++;
        } else {
            i = i - j +1;
            position = i;
            j = 0;
            n = 0;
        }
    }
    return position+1;
}
```





## KMP算法

KMP算法比较时，目标串与子串字符依次比较，匹配时，两个下标都后移，当出现不匹配时，目标串下标不变，子串下标改变(利用最大公共前后缀)，当目标串比较完即结束比较。



**KMP算法核心 - 最大公共前后缀长度**



**前缀：** 不能包含最后一个字母，**必须包含最前面的字母**

**后缀：** 不能包含最前一个字母，**必须包含最后面的字母**



设P串为**AAAAB**

我们令 `D[i] = P[0] ~ P[i]` 区间的最大公共前后缀长度

D[0] = P[0] ~ P[0] = P[0] - A 没有公共前后缀，为**0**

D[1] = P[0] ~ P[1] - AA 前缀为A、后缀为A，公共前后缀为A，长度为**1**

D[2] = P[0] ~ P[2] - AAA 前缀为A、AA 后缀为A、AA，最大公共前后缀为AA，长度为**2**

D[3] = P[0] ~ P[3] - AAAA 前缀为A、AA 、AAA 后缀为A、AA、AAA，最大公共前后缀为AAA，长度为**3**

D[2] = P[0] ~ P[4] - AAAAB 前缀为A、AA、AAA、AAAA 后缀为B、AB、AAB、AAAB，无公共前后缀，长度为**0**



KMP算法就是利用已经匹配的部分，匹配成功的部分目标串与子串相同，最大公共前后缀也相同，省略其最大公共前后缀的部分，将匹配加速

**下图为演示**

![KMP算法](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\KMP算法.png)



**解释：** 第一次匹配到P串下标为3处，此时前3位字符都与S串前3位相同 - AAA，匹配成功的部分最大公共前后缀为2，所以S串下次重新比较的位置下标为2。后同。



**KMP算法的一般分析**



**示例一**

![KMP-一般分析-1](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\KMP-一般分析-1.png)



假设P串在下标为i处于S串的下标j处不匹配(0开始)，前`j-1`个元素都相同，最大公共前后缀长度为`D[j-1]`，也就是说S串的前`D[j-1]`个元素与P串下标为i前的`D[j-1]`个元素相同。所以我们不必将S串的下一个比较位置从头开始，而是在下标为`D[j-1]`处开始也就是最大公共前后缀的后一位比较。如下图。



![KMP-一般分析-2](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\KMP-一般分析-2.png)



**示例二**



![KMP-一般分析-3](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\KMP-一般分析-3.png)

当S串开头就与P串不匹配时，最大公共前后缀为`D[j-1]` = `D[-1]`然而并没有意义。我们只能跟 `BF`算法一样，将P串往后移一位 - ++i，j不变， `D[0] = 0` 。



**代码计算最大公共前后缀**



**演示**

为了得到子串的最大公共前后缀，我们将它的后缀与前缀相匹配，匹配过程与KMP匹配完全一样



**匹配成功时**

![KMP-下标-1](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\KMP-下标-1.png)

得出`D[i] =  ++j`



**不匹配时**

计算子串不匹配的前部分的最大公共前后缀，移动j到下标`D[i-1]`处，继续匹配，匹配成功，则`D[i] =  ++j`，失败，当`j = 0`时，`i++`，直到上面的串匹配完即结束。



**KMP算法的代码实现**

```c

```

