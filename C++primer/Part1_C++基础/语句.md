# 语句



## 5.1-简单语句

无



## 5.2-语句作用域

- 定义在控制结构中的变量只在相应的语句内部可见

- 当循环迭代时，循环内定义的变量将会被重新初始化



## 5.3-条件作用域

- `if  if-else  if-else if-else`

- C++规定，悬垂的else与离它最近的尚未匹配的if匹配，从而消除了程序的二义性

- 建议使用花括号
- switch语句先对括号内表达式求值，表达式的值转为整型后与每个case标签的值比较。如匹配成功，则从匹配处开始顺序执行下面的所有case分支，除非显式中断。
- 为避免执行所有case分支，常用`break`中断switch语句。
- case关键字及其对应值一起称为`case标签`，对应的值必须为整型常量表达式。同一个switch内不能存在相同的case标签。
- `default`也是一种特殊的case标签，当没有一个case标签能匹配求值语句的值时执行default，即使不准备在default标签下做任何工作， 定义一个default标签也是有必要的
- 我们可以通过省略break来合并多个分支，实现多重匹配

跨过case可能会产生未定义的结果(不恰当的例子)

```c++
//程序的流程可能绕开初始化，故该switch语句不合法。
case true:
    string file_name;       //错，控制流绕过隐式初始化的变量
    int ival=0;             //错，控制流绕过显式初始化的变量
    int jval;               //对，jval未初始化
    break;
case false:
    jval=next_num();        //对，可给jval赋值。它在作用域内但未被初始化
    if (file_name.empty())  //file_name在作用域内，但未初始化
        ...
```



## 5.4-迭代语句

- `while()` 传统`for()`

- `for()`括号内的部分可省略，但`;`号不可少

- `do-while()`至少执行一次do内语句



## 5.5-跳转语句

-  `break与continue`

- break终止离它最近的while、do-while、for、switch，从它们之后的第一条开始执行。break只能出现在循环或switch内

- continue终止最近循环中的当前一次迭代，并开始下一次迭代。只能出现在for、while、do-while内

- goto无条件跳转到同一函数内的另一条语句，语法

  ```c++
  name: 语句;
  
  goto name;
  
  //or name: 语句;
  ```



## 5.6-try语句块和异常处理

- **异常**是程序运行时的反常行为，超出了函数正常功能的范畴
- 异常处理机制包括：**异常检测**和**异常处理**
- 异常处理包括**throw表达式**、**try语句块**、**异常类**



### 5.6.1-throw表达式

异常检测部分使用throw表达式引发一个异常，throw表达式包含throw关键字和紧随其后的一个表达式，表达式的类型是抛出异常的类型

```c++
if(a != b){
    throw runtime_error("must be same");
}
```

`runtime_error`是异常类的一种，定义于`stdexcept头文件`中。runtime_error必须由一个string对象或C风格字符串来初始化



### 5.6.2-try语句块

通用格式

```c++
try{
    program-statements
}
catch(exception-declaration){
    handler-statements
}
catch(exception-declaration){
    handler-statements
}
...
```

- try语句后跟一个或多个catch子句，catch子句包括三部分：关键字、括号内一个对象的声明(称作异常声明)、一个块

- try中是可能抛出异常的程序，抛出异常后与各catch子句捕获异常的类型对比，并执行匹配的catch子句

- try语句块中声明的变量在块外无法访问，即使是catch中也不行

```c++
while(cin>>item1>>item2){
    try{
        if(item1.isbn() != item2.isbn())
            throw runtime_error("Data must refer to same ISBN"); //抛出runtime_error类型异常
        cout<<item1+item2<<endl;
    }
    catch(runtime_error err){   //捕获runtime_error类型异常，存储到变量err中
        cout<<err.what()        //what成员函数得到抛出异常时的信息
            <<"\nTry Again? Enter y or n"
            <<endl;
        char c;
        cin>>c;
        if(!cin || c=='n')
            break;
    }
}
```

- what是runtime_error类的一个成员函数，每个标准库异常类都定义了名为what的成员函数，这些函数没有参数，返回值是C风格字符串



### 5.6.3-标准异常

- `exception头文件`定义最通用的异常类`exception`，它只报告异常的发生，不提供任何信息
- `stdexcept头文件`定义了几种常见异常类，见表5.1
- `new头文件`定义了异常类`bad_alloc`
- `type_info头文件`定义了异常类`bad_cast`



![5.6.3](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\5.6.3.png)

- 标准库异常类只定义了几种运算：创建、拷贝、赋值
- 对exception、bad_alloc、bad_cast只能使用默认初始化，不可提供初始值。其他异常类相反，不可默认初始化，必须提供string对象或C风格字符串做初值
- 每个异常类定义了`what方法`，该方法没有参数，返回值是指向C风格字符串的`const char *`，该字符串提供异常相关的文本。若该异常类型有字符串初始值，则what返回该字符串，若无初始值，则what返回值由编译器决定