# 函数



## 6.1-函数基础

- 函数可以`重载`，即一个名字对应多个不同函数

- `函数定义`包括：`返回类型`、`函数名字`、由0个或多个形参组成的`形参列表`、`函数体`

- **实参**：调用函数时传入的参数，**形参**：自定义函数创建时的参数

- 为与C兼容，可用`void关键字`表示函数没有形参

- 函数的返回类型不能是数组或者函数，但能是指向它们的指针



### 6.1.1-局部对象

- 形参和函数体内定义的变量统称为**局部变量**，只在它所在的作用域内可见

- 局部变量是一种**自动对象**，当执行到包含它的块(函数)的末尾会被销毁

- 在局部变量前加上 `static`关键字，使局部对象变为**局部静态对象**，在程序执行第一次经过定义语句时初始化，直到程序终止才被销毁，在此期间它所在的函数结束运行也不会照成影响



### 6.1.2-函数声明

- 函数只能定义一次，但可声明多次



### 6.1.3-分离式编译

- C++支持分离式编译，即允许将程序分割到几个文件中，每个文件单独编译

```shell
$ CC -c factMain.cc             #产生factMain.o
$ CC -c fact.cc                 #产生fact.o
$ CC factMain.o fact.o -o main  #将两个对象文件链接为可执行文件
#CC为编译器名字
```

- 大多数编译器提供了分离式编译每个文件的机制，这 一过程通常会产生一个后缀名是`.obj`(Windows) 或`.o` (UNIX) 的文件



## 6.2-参数传递

- **传引用调用**：当形参是引用类型时，实参和形参是一个对象
- **传值调用**：实参的值被拷贝给形参，形参和实参是两个独立的对象



### 6.2.1-传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时对变量的改变不会影响初始值

- 指针形参只能改变实参指针所指向的对象，而不能改变实参指针指向



### 6.2.2-传引用参数

- 对于引用的操作实际上是作用在引用绑定的对象上

- 如果函数无须改变引用形参的值，最好将其声明为**常量引用**



### 6.2.3-const形参和实参

- 顶层const作用于对象本身

- 使用实参初始化形参时会忽略顶层const，当形参有顶层const时，传const对象或非const对象都可以

- **函数重载**：在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别

```c++
//下面两个函数可接受相同参数，故是相同函数，不可重载
void fcn(const int i){}
void fcn(int i){} //错，重复定义
```



### 6.2.4-数组形参

数组会自动转换成指针

```c++
//以下3个函数等价，形参类型都是const int *
void print(const int *);
void print(const int []);
void print(const int [10]);
```



**数组引用形参**

```c++
void print(int (&arr)[10]){ //形参是数组的引用，数组不转指针，实参大小也必须符合
    for(auto elem:arr)
        cout<<elem<<endl;
}
```



**传递多维数组**

```c++
//以下两定义等价
void print(int (*matrix)[10], int rowSize){}    //指针形式传入二维数组
void print(int matrix[][10], int rowSize){}     //数组形式传入二维数组，第一个维度可省略
```



### 6.2.5-main:处理命令行选项



```c++
int main(int argc, char *argv[]){}
int main(int argc, char **argv){}
```

- `argv`是一个数组，其元素是指向C风格字符串的指针。`argc`表示数组长度



**向main传递参数**

```shell
$ prog -d -o ofile data //假定main函数位于可执行文件prog下
```



### 6.2.6-含可变形参的函数

- 有时候无法预知函数会被传入多少个实参，此时用**可变形参**

- C++11，如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型



**initializer_list形参**

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用**initializer_list**类型的形参



![6.2.6](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\6.2.6.png)

- 和vector一样initializer_list也是一种模板类型，定义其对象时必须指明元素类型
- initializer_list对象中的元素永远是**常量**，无法改变

```c++
initializer_list<int> i;
```



**省略符形参**

- 省略符形参只能出现在形参列表的最后，省略符形参对应的实参无需类型检查



## 6.3-返回类型和return语句

 