# 函数



## 6.1-函数基础

- 函数可以`重载`，即一个名字对应多个不同函数

- `函数定义`包括：`返回类型`、`函数名字`、由0个或多个形参组成的`形参列表`、`函数体`

- **实参**：调用函数时传入的参数，**形参**：自定义函数创建时的参数

- 为与C兼容，可用`void关键字`表示函数没有形参

- 函数的返回类型不能是数组或者函数，但能是指向它们的指针



### 6.1.1-局部对象

- 形参和函数体内定义的变量统称为**局部变量**，只在它所在的作用域内可见

- 局部变量是一种**自动对象**，当执行到包含它的块(函数)的末尾会被销毁

- 在局部变量前加上 `static`关键字，使局部对象变为**局部静态对象**，在程序执行第一次经过定义语句时初始化，直到程序终止才被销毁，在此期间它所在的函数结束运行也不会照成影响



### 6.1.2-函数声明

- 函数只能定义一次，但可声明多次



### 6.1.3-分离式编译

- C++支持分离式编译，即允许将程序分割到几个文件中，每个文件单独编译

```shell
$ CC -c factMain.cc             #产生factMain.o
$ CC -c fact.cc                 #产生fact.o
$ CC factMain.o fact.o -o main  #将两个对象文件链接为可执行文件
#CC为编译器名字
```

- 大多数编译器提供了分离式编译每个文件的机制，这 一过程通常会产生一个后缀名是`.obj`(Windows) 或`.o` (UNIX) 的文件



## 6.2-参数传递

- **传引用调用**：当形参是引用类型时，实参和形参是一个对象
- **传值调用**：实参的值被拷贝给形参，形参和实参是两个独立的对象



### 6.2.1-传值参数

- 当初始化一个非引用类型的变量时，初始值被拷贝给变量，此时对变量的改变不会影响初始值

- 指针形参只能改变实参指针所指向的对象，而不能改变实参指针指向



### 6.2.2-传引用参数

- 对于引用的操作实际上是作用在引用绑定的对象上

- 如果函数无须改变引用形参的值，最好将其声明为**常量引用**



### 6.2.3-const形参和实参

- 顶层const作用于对象本身

- 使用实参初始化形参时会忽略顶层const，当形参有顶层const时，传const对象或非const对象都可以

- **函数重载**：在C++语言中，允许我们定义若干具有相同名字的函数，不过前提是不同函数的形参列表应该有明显的区别

```c++
//下面两个函数可接受相同参数，故是相同函数，不可重载
void fcn(const int i){}
void fcn(int i){} //错，重复定义
```



### 6.2.4-数组形参

数组会自动转换成指针

```c++
//以下3个函数等价，形参类型都是const int *
void print(const int *);
void print(const int []);
void print(const int [10]);
```



**数组引用形参**

```c++
void print(int (&arr)[10]){ //形参是数组的引用，数组不转指针，实参大小也必须符合
    for(auto elem:arr)
        cout<<elem<<endl;
}
```



**传递多维数组**

```c++
//以下两定义等价
void print(int (*matrix)[10], int rowSize){}    //指针形式传入二维数组
void print(int matrix[][10], int rowSize){}     //数组形式传入二维数组，第一个维度可省略
```



### 6.2.5-main:处理命令行选项



```c++
int main(int argc, char *argv[]){}
int main(int argc, char **argv){}
```

- `argv`是一个数组，其元素是指向C风格字符串的指针。`argc`表示数组长度



**向main传递参数**

```shell
$ prog -d -o ofile data //假定main函数位于可执行文件prog下
```



### 6.2.6-含可变形参的函数

- 有时候无法预知函数会被传入多少个实参，此时用**可变形参**

- C++11，如果所有的实参类型相同，可以传递一个名为`initializer_list`的标准库类型



**initializer_list形参**

如果函数的实参数量未知但是全部实参的类型都相同，我们可以使用**initializer_list**类型的形参



![6.2.6](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\6.2.6.png)

- 和vector一样initializer_list也是一种模板类型，定义其对象时必须指明元素类型
- initializer_list对象中的元素永远是**常量**，无法改变

```c++
initializer_list<int> i;
```



**省略符形参**

- 省略符形参只能出现在形参列表的最后，省略符形参对应的实参无需类型检查



## 6.3-返回类型和return语句

-  返回值为void的函数无需`return`语句，函数末尾会隐式执行`return;`

- 有返回值的函数必须通过显式的return返回，返回类型必须匹配

- 函数返回值的方式和初始化变量、形参一样：返回的值用于初始化调用点的一个临时量，该临时量是调用表达式的结果

- **不可返回局部对象的引用或指针**：函数终止意味着局部变量的引用将指向不再有效的内存区域，内存将会被销毁



**列表初始化返回值**

```c++
vector<string> process(){
    if(expected.empty())        return {};                              //返回vector被值初始化
    else if(expected==actual)   return {"functionX","OK"};              //返回vector被列表初始化
    else                        return {"functionX",expected,actual};   //返回vector被列表初始化
}
```



**主函数main的返回值**

- 我们允许main函数没有return语句直接结束。如果控制到达了main函 数的结尾处而且没有return语句，编译器将隐式地插入一条返回0的return语句

- main函数的返回值可以看做是状态指示器。返回0表 示执行成功，返回其他值表示执行失败，其中非0值的具体含义依机器而定

- `cstdlib`头文件定义了两个须处即变址，我们可以使用这两个变量分别表示成功与失败

```c++
#include <iostream>
#include <cstdlib>

int main()
{
    if(some_failure){
        return EXIT_FAILURE; //预处理器变量
    } else {
        return EXIT_SUCCESS;
    }
}
```



**递归**

- 函数直接或间接调用它自身

- main函数不能调用它自己



### 6.3.3-返回数组指针

- 使用类型别名简化数组

```c++
typedef int arrT[10];   //arrT等价于长度为10的整型数组，不会转指针
using arrT=int[10];     //等价于上一行，arrT等价于长度为10的整型数组，不会转指针
arrT *func(int i);      //函数返回指向arrT的指针
```

- 函数不能传递数组，但是可以用指针或引用间接传递



**声明一个返回数组指针的函数**

```c++
Type (*function (parameter_list)) [dimension]
//int (*func(int i)) [10]; 
```

type表示元素的类型，dimension表示数组的大小，parameter_list为形参列表， (*function(parameter_list)）两端的括号必须存在



**使用尾置返回类型**

```c++
auto func(int i) -> int(*)[10]; //尾置返回声明，函数接收int型实参，返回一个指针，该指针指向大小为10的int数组
int (*func(int i))[10]; 
```

c++11，任何函数的定义都能仗用尾置返回， 但是这种形式对于返回类型比较复杂的函数最有效， 比如返回类型是数组的指针或者数组的引用。尾置返回类型放在形参列表后，并以`->`开头，代替原来返回类型的地方使用`auto`。



**使用decltype**

```c++
int odd[]={1,3,5,7,9};
int even[]={0,2,4,6,8};
decltype(odd) *arrPtr(int i){ //推导返回类型为数组指针
    return (i%2)?(&odd):(&even);
}
```



## 6.4-函数重载

- 如果同一作用域内的几个函数名字相同但形参列表不同， 我们称之为重载函数。 

- main函数不能重载

- 对于重载的函数来说，它们应该在形参数量或形参类型上有所不同

```c++
Record lookup(const Account &acct）； 
Record lookup(const Account&); //省略了形参的名字
typedef Phone Telno; 
Record lookup(const Phone&};
Record lookup(const Telno&}; // Telno和Phone的类型相同
//以上函数都不能重载
```

- **顶层const不影响传入函数的对象**

```c++
Record lookup(Phone *);
Record lookup(Phone * const);
//顶层cosnt，不能重载
Record lookup(const Phone *); //可以重载
```



**const_cast和重载**



**调用重载的函数**

- 找到最佳匹配的函数
- 找不到任何函数与实参匹配，无匹配错误
- 匹配到多于一个函数，但每一个都不是最佳，**二义性**调用错误



### 6.4.1-重载与作用域

 如果我们在内层作用域中声明名字， 它将隐藏外层作用域中声明的同名实体。 在不同的作用域中无法重载函数名

```c++
void print(string *);
void print(int);

int main()
{
    print(1);
    string print = "hello world!";
    print("hello"); //错误，隐藏了print函数，无法调用
    return 0;
}
```

- C++中，名字查找发生在类型检查之前



## 6.5-特殊用途语言特性



### 6.5.1-默认实参

- 函数调用时，可以不输入实参，而使用默认的值
- 如果我们想使用默认实参，只要在调用函数的时候省略该实参就可以了

```c++
string screen(sz ht = 24, sz wid =80, char background = ''); //函数声明

string widow;
widow = screen(); //默认实参
widow = screen(66); //ht = 66
widow = screen(66, 80); //ht = 66 wid = 80
widow = screen( , , '#'); //错误，只能省略尾部实参
```

- 我们为每一个形参都提供了默认实参，默认实参作为形参的初始值出现在形参列表中



**默认实参的声明**

- 在给定作用域中一个形参只能被赋予一次默认实参

```c++
string screen(sz, sz, char background = '');
string screen(sz, sz, char background = '*'); //错误
string screen(sz ht = 60, sz wid = 80, char); //正确
```



**默认实参初始值**

- 局部变量不可作为默认实参
- 默认实参的名字在声明作用域中解析，但求值发生在调用时

```c++
sz wd=80;
char def=' ';
sz ht();
string screen(sz=ht(), sz=wd, char=def); //声明函数，带有默认实参
string window=screen(); //screen(ht(),80,' ')
void f2(){
    def='*';            //def变量仍是外部的
    sz wd=100;          //内部重新定义了wd变量
    window=screen();    //默认实参的名字在外部解析，故为screen(ht(),80,'*')
}
```



### 6.5.2-内联函数和constexpr函数

- 内联函数可避免函数调用的开销，作用是展开函数

- 在函数返回类型前加上关键字**inline**即可将函数声明为内联函数

- 内联说明只是向编译器发出的请求，编译器可将其忽略

- 内联适合用规模小、流程直接、调用频繁的函数。很多编译器不支持内联递归函数



**constexpr函数**

- 能用于常量表达式的函数的函数，定义constexpr函数的方法与其他函数类似， 不过要遵循几项约定： 函数的返回
  类型及所有形参的 类型都得是字面值类型， 而且函数体中必须有且只有一条return语句

- constexpr函数被隐式地指定为内联函数

- 我们允许constexpr函数返回值非常量

```c++
constexpr int new_sz() {return 42;}                         //返回常量表达式
constexpr size_t scale(size_t cnt) {return new_sz()*cnt;}   //形参非常量，返回值非常量
int arr[scale(2)];  //对，scale输入常量表达式时输出即是常量表达式
int i=2;
int a2[scale(i)];   //错，scale输入不是常量表达式，输出也不是常量表达式
```

- constexpr函数不一定返回常量表达式



### 6.5.3-调试帮助



**assert预处理宏(预处理变量)**

- assert宏使用一个表达式作为它的条件：`assert(expr);`，首先对expr求值，如果表达式为假（即0),assert输出信息并终止程序的执行。如果 表达式为真（即非0),assert什么也不做

- 定义在`cassert`头文件中



**NDEBUG预处理变量**

- assert的行为依赖于一个名为NDEBUG的预处理变量的状态。如果定义了NDEBUG， 则assert什么也不做。默认状态下没有定义NDEBUG，此时assert将执行运行时检查

- 我们可以使用一个#define语句定义NDEBUG，从而关闭调试状态

```shell
$ CC -D NDEBUG main.C # use /D with the Microsoft compiler
#等价于在main.c文件的一开始写＃define NDEBUG
```



```c++
void print(const int ia[], size_t size){
#ifndef NDEBUG  //只有调试状态才执行中间的代码
    cerr<<__func__<<": array size is "<<size<<endl; //__func__是编译器定义的一个局部静态变量用于储存函数的名字
#endif
//...
}
```



**预处理器定义了另外几个对调试有用的名字**

- `__FILE__`存放文件名的字符串字面值
- `__LINE__`存放当前行号的整型字面值
- `__TIME__`存放文件编译时间的字符串字面值
- `__DATE__`存放文件编译日期的字符串字面值



## 6.6-函数匹配

- 当几个重载的函数形参数量相等且某些形参类型可转化时，函数匹配比较困难
- `第一步`：按名字筛选。要求：1、与被调用函数同名；2、在调用点可见。这些函数称为`候选函数`
- `第二步`：按实参筛选。要求：1、形参与实参数量匹配；2、形参与实参类型匹配，或实参能转换为形参。这些函数称为`可行函数`，如果没有可行函数，编译器报错：`无匹配函数`
- `第三步`：选择最匹配。实参与形参类型越接近则匹配得越好，精确匹配比需要类型转换的匹配更好。
- 选择最匹配时，如果有且仅有一个函数满足以下条件，则匹配成功，否则编译器报错：二义性调用
  - 该函数每个实参的匹配都不劣于其他可行函数
  - 该函数至少有一个实参的匹配优于其他可行函数

```c++
void f();
void f(int);
void f(int,int);
void f(double,double=3.14);
f(5.6)      //(double,double)精确匹配
f(42,2.56)  //第一个实参与(int,int)匹配更好，第二个实参与(double,double=3.14)匹配更好，二义性调用
```

- 调用重载函数时尽量避免强制转换。设计良好的系统中不应对实参做强制转换



### 6.6.1-实参类型转换

**匹配等级排序**

1. 精确匹配，包括：类型相同、数组转指针、函数转指针、改变顶层const
2. 通过const转换实现的匹配
3. 通过类型提升实现的匹配
4. 通过算术转换或指针转换实现的匹配
5. 通过类类型转换实现的匹配

```c++
//整型提升
void ff(int);
void ff(short);
ff('a');        //char提升为int，调用(int)
//算术转换
void manip(long);
void manip(float);
manip(3.14);    //浮点字面值是double，转换到long和float代价一样，二义性调用
```



**函数匹配和const 实参**
如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过头参是否是常从来决定选择哪个函数

```c++
Record lookup(Account &);
Record lookup(const Account &);
const Account a;
Account b;
lookup(a);      //底层const只能与底层const匹配，调用(const Account &)
lookup(b);      //底层非const优先与底层非const匹配，调用(Account &)
```



## 6.7-函数指针

- 函数指针指向的是函数而非对象
- 函数的类型由其返回值类型和形参类型共同决定，与函数名和形参名无关

```c++
bool lengthCompare(const string &, const string &); //类型是：bool(const string &, const string &)
bool (*pf)(const string &, const string &); //声明指向上面的函数的指针，未初始化
```

- pf前面有个*， 因此pf是指针；右侧是形参列表， 表示pf 指向的是函数；pf就是一个指向函数的指针， 其中该函数的参数是两个const string的引用， 返回值是bool类型
- *pf两端的括号必不可少。 如果不写这对括号， 则pf是一个返回值为bool 指针的函数



**使用函数指针**

- 当我们把函数名作为值使用时，函数自动转为指针，我们还能直接使用指向函数的指针调用该函数， 无须提前解引用指针

```c++
bool lengthCompare(const string &, const string &); //类型是：bool(const string &, const string &)
bool (*pf)(const string &, const string &);         //声明对应类型的函数指针，未初始化
pf=&lengthCompare;              //初始化函数指针
pf=lengthCompare;               //等价于上一句。因为函数名转为指针，故取地址符是可选的
//下面3条语句互相等价
bool b1=pf("hello","goodbye");  //解引用符是可选的
bool b2=(*pf)("hello","goodbye");
bool b3=lengthCompare("hello","goodbye");
```



**若定义了指向重载函数的指针，则指针类型必须与某一函数精确匹配**



**函数指针形参**

和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际上却是当成指针使用

```c++
//笫三个形参是函数类型，它会自动地转换成指向函数的指针
void useBigger(const string &sl, const string &s2, bool pf(const string&, const string&)); //等价的声明：显式地将形参定义成指向函数的指针
void useBigger(const string &s1, const string &s2, bool (*pf) (const string &, const string &));

//自动将函数lengthCompare转换成指向该函数的指针
useBigger(s1, s2, lengthCompare); 
```



**指向函数的指针**

- 不能将函数作为返回值，但能将函数指针作为返回值
- 函数指针作为返回值时，必须明确写成指针。返回值中的函数类型不会被自动转为指针
- 可用类型别名和尾置返回类型简化函数指针作为返回值的函数原型

```c++
using F=int(int*,int);              //是函数类型
using PF=int(*)(int*,int);          //是函数指针类型
int (*f1(int))(int*,int);           //直接声明
PF f1(int);                         //返回指向函数的指针，等价于上一行
F *f1(int);                         //返回指向函数的指针，等价于上一行
F f1(int);                          //错，不能返回函数
auto f1(int) -> int(*)(int*,int);   //等价于原声明
```

- auto和decltype也可用于返回函数指针的原型

```c++
string::size_type sumLength(const string &, const string &);
string::size_type largerLength(const string &, const string &);
decltype(sumLength) *getFcn(const string &); //返回指向上面两函数之一的指针
```

