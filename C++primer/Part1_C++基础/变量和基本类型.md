# 变量和基本类型



## 2.1-基本内置类型

基本数据类型: 算术类型(字符、 整型数、 布尔值和浮点数)、空类型(void)



### 2.1.1-算术类型

算术类型分为两类： 整型、浮点型

算术类型的尺寸在不同机器上有所差别



**C++算术类型**

![](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\C++_2.1.1.png)

- bool的取值为true或false

- 一个char的大小等于一个机器字节

- 其他字符类型用于扩展字符集， 如wchar_t、 char16_t、 char32_t

- wchar_t - 用于储存如中文、日文等字符

- 一个英文字符占1字节，中文字符占2字节

- C++语言规定：一个int比至少和一个short一样大，一个long至少和一个int一样大，一个long long(C++11)至少和一个long一样大



**浮点型**

- 浮点型可表示单精度 、双精度和扩展精度值
- 通常，float以1个字( 32）比特来表示，double以2个字(64比特）来表示， long double以3或4个字(96或128 比特）来表示
- 类型float和double分别有7和16个有效位



**带符号类型和无符号类型**

- 通常在类型(int、 short、 long和long long)前加上unsigned来获得无符号类型，带符号类型可以表示正数、 负数或0, 无符号类型则仅能表示大于等于0的值。类型unsigned int可以缩写为unsigned。



- 与其他整型不同，字符型被分为了三种：char、signed char和unsigned char。尽管字符型有三种，但特别需要注意的是：类型char和类型signed char并不是字符的表现形式却只有两种：带符号的和无符号的。类型char实际上会表现为上述两种形式中的一种， 具体是哪种由编译器决定。

- 在大多数计算机上8比特的signed char所表示的范围为－128至127



**建议：如何选择类型**

- 明确知晓数值不可能为负时， 选用无符号类型
- 用int执行整数运算。在实际应用中，short常常显得太小而 long一般与int一样的尺寸，如果超过了int的尺寸使用long long
- 算术表达式中不要使用char或bool
- 执行浮点数运算选用double，浮点数以double的形式储存在内存中



### 2.1.2类型转换

当在程序的某处我们使用了某种类型而对象而实际应取另一种类型时，程序会自动进行类型转换，称为自动类型转换

- 非布尔类型转布尔类型时，0值为false，非0值为true

- 布尔转非布尔，true为1，flase为0
- 浮点数转整数，会截断小数点后的数
- 整型转浮点，小数部分是0，若整型数超过浮点容量，有精度损失
- 给unsigned赋超出范围的值，初始值对该unsigned类型最大值取模
- 给signed赋超出范围的值，未定义
- 算术表达式中同时有signed和unsigned，会将signed自动转为unsigned



**含有无符号类型的表达式**

当一个算术表达式中既有无符号数又有int值时，那个int值就会转换成无符号

```c++
unsigned u = 10; 
int i= -42; 
std::cout<< i + i << std::endl; // 输出－84
std::cout << u + i << std::endl; //如果int占32位,输出4294967264，这里i被取模
```



**提示：切勿混用带符号类型和无符号类型**



### 2.1.3 字面值常型

一个形如42的值被称作字面值常量



**整型和浮点型字面值**

- `20/十进制  024/八进制  Ox14/十六进制`

- 默认的，浮点型字面值是一个double



**字符和字符串字面值**

- 编译器在每个字符串的结尾处添加一个空字符('\0'），因此，字符串字面值的实际长度要比它的内容多1



**转义序列**

转义序列被当作一个字符使用



**指定字面值的类型**

```c++
L'a'     //宽字符型字面值，类型是wchar_t
u8"hi!"  //utf-8字符串字面值（utf-8用8bit编码一个unicode字符）
42ULL    //无符号整型字面值，类型是unsigned long long
1E-3F    //单精度浮点字面值，类型是float
3.14159L //扩展精度浮点字面值，类型是long double
```



![](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\C++_2.1.3.png)



## 2.2-变量

对C++程序员来说， “变量"和 “对象"一般可以互换使用



### 2.2.1-变量定义



**列表初始化(C++11新标准)**

```c++
int units_sold = O;
int units_sold = {0};
int units_sold{0};
int units_sold(0);
//等效
```

如果我们使用列表初始 化且初始值存在丢失信息的风险，则编译器将报错

```c++
long double ld = 3.1415926536;
int a {ld}, b = {ld}; //报错
int c(ld), d = ld; //正确
```



**默认初始化**

如果定义变量时没有指定初值， 则变量被默认初始化

- 定义在函数体内部的内置类型变量将不被初始化

- 建议初始化每一个内置类型的变量



### 2.2.2-变量声明和定义的关系

- **声明**使得名字为程序所知，而**定义**负责创建与名字关联的实体(创建空间)

- 声明规定了变量的类型和名字；定义申请存储空间，也可能会为变量赋一个初始值


- **变量能且只能被定义一次， 但是可以被多次声明。**



**如果想声明一个变量而非定义它， 就在变量名前添加关键字extern, 而且不要显式地初始化变量**

```c++
extern int i;//声明i
int i;//声明并定义i
extern int i = 0;//抵消了extern的作用，定义i
```

**在函数体内部，如果试图初始化一个由extern关键字标记的变量，将引发错误。**



**C++是一种静态类型语言，其含义是在编译阶段检查类型。其中，检查类型的过程称为类型检查**



### 2.2.3-标识符

变量名由字母数字或下划线组成，必须以字母或下划线开头，对大小写敏感



**命名规范**

- 名字要有意义
- 一般用小写字母
- 自定义的类名一般以大写字母开头
- 如果名字由多个单词构成，单词间应该有明显划分 如: `StudentLoan`
- 不能使用C++的**关键字**来命名



### 2.2.4-名字的作用域

C++中作用域一般以花括号分隔，花括号为一个块

- 块作用域：块内定义的对象不能在块外使用，结果是未定义的

- 全局作用域：在整个程序中都可使用



## 2.3-复合类型

复合类型是指基于其他类型定义的类型，C++语言有几种复合类型，这里介绍其中的两种： 引用和指针



### 2.3.1-引用

引用为对象起了另外一个名字，与其绑定，引用即别名，引用并非对象，相反的，它只是对一个已经存在的对象所起的另外一个名字

```c++
int i = 1024;
int &j = i; //j是i的一个引用，值为1024
int &k; //错误，引用必须初始化
int &a = j; //a = 1024
double &b = i; //错误，类型必须相匹配
```



**引用必须初始化**

程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给引用。一旦初始化完成，引用将和它的初始值对象一直绑定在一起。囚为无法令引用重新绑定到另外一个对象，因此引用必须初始化。



引用只能绑定在对象上，而不能与一字面值或某个表达式的计算结果绑定在一起

```c++
int &i = 1024; //错误，初始值必须为对象
const int &i = 1024; //正确，后续将会解释
```



### 2.3.2-指针

- 指针：指针指向某个地址
- 指针变量：指针变量储存地址



**获取对象地址**

```c++
int i = 1024;
double k = 3.14;
int *p = &i; //p指向i
int &j = i;
p = &j; //错误，引用不是对象
p = &k; //错误，类型不匹配
```

**引用不是对象，没有实际地址，所以不能定义指向引用的指针**

**指针与引用一样，只能指向相同类型的对象**



**用指针访问对象**

解引用运算符 `*` ，访问指针所指对象的值

```c++
int i = 1024;
int *p = &i;
std::cout << *p << std::endl; //输出，1024
```



**空指针**

空指针(nullpointer)不指向任何对象

得到空指针的三种方法：

```c++
int *p = 0;
int *p = NULL; //预处理变量，这个变量在头文件cstdlib中定义
int *p = nullptr; //C++11新标准
```

**现在的C++程序最好使用nullptr**



**任何非0指针对应的条件值都是true**

```c++
int *p1 = nullptr;
int i =1024;
int *p2 = &i;
if(p1){
    ...
}//false
if(p2){
    ...
}//true
```



**建议初始化所有指针**



**void*指针**

void＊是一种特殊的指针类型，可用于存放任意对象的地址，我们对该地址中到底是个什么类型的对象
并不了解，利用void指针能做的事儿比较有限



### 2.3.3-理解复合类型的声明

即同时定义多个变量

```c++
int *p, pi; //p为指针变量，pi为整型变量
int *p, *pi; //都为指针变量
```



**指向指针的指针**

```c++
int ival = 1024; 
int *pi= &ival; //pi指向一个int型的数
int **ppi = &pi; //ppi指向一个int类型的指针
```



**指向指针的引用**

```c++
int *p;
int *&r= p;
```

要理解r的类型到底是什么，最简单的办法是**从右向左阅读r的定义**。离变量名最近的符号，此例中是＆r的符号&对变量的类型有最直接的影响，因此r是一个引用



## 2.4-const限定符

使用const前缀将变量定义为常数，其值不会改变

```c++
const int i = 1024;
const int j; //错误，必须初始化
i = 0; //错误，向常数写值 1024 ！= 0
```



**默认状态下，const 对象仅在文件内有效**

默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的 const变量时，其实等同于在不同文件中分别定义了独立的变量

要想只在一个文件中 定义const，而在其他多个文件中声明并使用它。解决的办法是，对于const变量不管是声明还是定义都添加extern关键字

```c++
//file_l.cc定义并初始化了一个常岳，该常量能被其他文件访问
extern const int bufSize = fen();
// file_l.h头文件
extern const int bufSize;//与file_l.cc中定义的bufSize是同一个
```



### 2.4.1-const的引用

对常量的引用不能被用作修改它所绑定的对象



**对常量的引用**

`const int &i = 1024;`



**对const的引用可能引用一个井非const的对象**

```c++
int i = 1024;
const int &j = i;
```



### 2.4.2-指针和const



要想存放常量对象的地址，只能使用指向常量的指针

```c++
const double pi = 3.14;
const double *p_pi;
p_pi = &pi;
```



**const指针**

把＊放在const关键字之前用以说明指针是一个常量，即无法改变指针指向

```c++
int i =1024;
int j = 0;
int * const p = &i; //指针指向i
p = &j; //错误，不能改变指针指向
```



**顶层const**

用名词**顶层 const**表示指针本身是个常量，即`*`在const前，**底层 const**表示指针所指的对象是一个常量，即`*`在const后



### 2.4.4-constexpr和常量表达式

C++11新标准规定，允许将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式。声明为constexpr的变量一定是一个常量，而且必须用常量表达式初始化。

```c++
constexpr int i = 1024;
```

如果你认定变量是一个常量表达式，那就把它声明成constexpr 类型。

一个constexpr指针的初始值必须是nullptr或者0，或者是存储千某个固定地址中的对象



**指针和constexpr**

在constexpr声明中如果定义了一个指针，限定符constexpr仅对指针有效， 与指针所指的对象无关



## 2.5-处理类型



### 2.5.1 -类型别名

传统的方法是使用关键字**typedef**

```c++
typedef int i;
i a = 4;
```

新标准规定了一种新的方法， 使用**别名声明-using**

```c++
using i = int;
i a = 1024;
```



**指针、常量和类型别名**



### 2.5.2 -auto类型说明符

C++11新标准引入了auto类型说明符,auto让编译器通 过初始值来推算变量的类型。

```c++
auto i = 1024;//i为int型
```



auto一般会忽略掉顶层const，底层const会保留

```c++
const int ci = i, &er = ci; 
auto b = ci;
auto c= cr; 
auto e = &ci;
```

**如果希望推断出的auto类型是个顶层const， 需要明确指出**

`const auto i = 1024;`

还可以将引用的类型设为auto, 此时原来的初始化规则仍然适用：

`auto &g = ci;`



### 2.5.3-decltype类型指示符

C++11新标准引入了第二种类型说明符 decltype, 它的作用是选择并返回操作数的数据类型。编译器分析表达式并得到它的类型，却不实际计算表达式的值

```c++
decltype(int) i = 1024; //i为int型
decltype(i) a = 1024;
decltype((i)) b = i; //b是i的引用 int &b = i;
```

**切记：decltype ((variable))（注意是双层括号）的结果永远是引用，而 decltype(variable)结果只有当variable本身就是一个引用时才是 引用。**



## 2.6-自定义数据结构

创建一个类有两种方法:struct、class（区别在后面介绍）

注意struct后的分号必不可少



**类数据成员**

类的数据成员定义了类的对象的具体内容，定义数据成员的方法和定义普通变量一样



**预处理器概述**