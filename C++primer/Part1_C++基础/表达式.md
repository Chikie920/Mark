# 表达式



## 4.1-基础

- 一元运算符作用于一个对象：`&`、`*` ，二元运算符作用于两个对象：`==` 、`*`、`+` 等，三元运算符：`? :`

- 在表达式求值的过程中， 运算对象常常由一种类型转换成另外一种类型，小整数类型（如bool、char、short等）通常会被提升(promoted) 成较大的整数类型，主要是int

- 当一个对象被用作**右值**的时候， 用的是对象的值（内容）； 当对象被用作**左值**的时候， 用的是对象的身份（在内存中的位置）。
- 大多数情况下我们无法知道求值顺序 `int i = f1() * f2();`

- 对于那些没有指定执行顺序的运算符来说，如果表达式指向并修改了同一对象会引发错误并产生未定义的行为 `cout << i << ++i;`



## 4.2-算术运算符

- 一元 `+ -`     二元`+ - * / %`
- 取余`%`的运算对象必须都是整型，不可用浮点型，且结果的正负性与`%`号前的值相关



## 4.3-逻辑关系运算符

- 逻辑运算符 `! = != <= >= == < > || &&`

- 指针指向0时，条件为false，有指向时为true



## 4.4-赋值运算符

- 赋值运算符满足右结合律
- 赋值运算符的左侧对象必须是可修改的左值，其返回结果就是左侧对象
- 如果左右类型不匹配，将右侧转为左侧类型



## 4.5-递增和递减运算符

- 除非必须，否则不用递增递减运算符的后置版本
- 前置版本将对象+1或-1后，将对象`本身`作为`左值`返回，后置版本将对象+1或-1后，将对象`原始值`的`副本`作为`右值`返回

```c++
int i = 0, j = 0;
cout << i++ << ++j << endl;
//输出01
```

- 后置递增运算符的优先级高于解引用运算符，因此`*pbeg++`等价于`*(pbeg++)`



## 4.6-成员访问运算符

- 点运算符和箭头运算符都可用访问成员，点运算符`.`获取类对象的一个成员，箭头运算符于点运算符有关 `p->data`等价于 `(*p).data`

- 解引用运算符`*`的优先级低于点运算符



## 4.7-条件运算符

-  `cond?expr1:expr2` ，cond为真返回expr1
- 条件运算符满足`右结合律`，即`a?b:c?d:e`应解读为`a?b:(c?d:e)`



## 4.8-位运算符



![4.8](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\4.8.png)

- 位运算符作用于`整型`对象。另外，一种名为`bitset`的标准库类型也可表示任意大小的二进制位集合，位运算符也可作用于`bitset`对象。
- 位运算符遇到小整型（如bool、char、short等），会先将其自动提升再运算。
- 如果位运算符的运算对象是signed且值为负，则处理符号位的方式取决于机器。左移右移会改变符号位，是未定义行为。
- 移位运算符`<<`和`>>`：首先令左侧运算对象按照右侧运算对象的要求移动指定位数，然后将移动后的（可能被提升了）左侧对象的`拷贝`作为结果。其中右侧对象一定不能为负，且值必须严格小于左侧位数。移出边界的位被舍弃。
- 移位运算符满足`左结合律`
- 左移运算符向右侧插入0，右移运算符向左侧插入的数值取决于类型和机器：unsigned类型插入0，signed类型取决于机器和编码方式。
- 例子：移位和整型提升

```c++
unsigned char bits=0233;    //10011011
bits<<8;    //提升为int大小，再左移8位，00000000 00000000 10011011 00000000
bits<<31;   //提升为int大小，再左移31位，10000000 00000000 00000000 00000000
bits>>3;    //提升为int大小，再右移3位，00000000 00000000 00000000 00010011
```

- 对char等小整型按位取反`~`也会先提升为int大小再取反。



## 4.9-sizeof运算符

- sizeof运算符返回一条`表达式`或一个`类型`所占的`字节数`，满足`右结合律`，返回值是`size_t`类型的`常量表达式`



## 4.10-逗号运算符

- 接受两个对象，遵循`从左往右`的求值顺序，首先对左侧的表达式求值， 然后将求值结果丢弃掉，返回右值



## 4.11-类型转换

- **隐式转换**自动执行

- 隐式转换发生的情形：

1. 整型提升
2. 条件中非bool转bool
3. 初始化时初始值转为变量类型，赋值时右侧对象转为左侧类型
4. 算术运算或关系运算中有多种类型，最终会统一
5. 函数调用时也会有类型转换



### 4.11.1-算术转换

- 当存在两个类型的运算时，将小类型转换为大的
- 整型提升：把小整型转为大整型，bool、char、signed char、unsigned char、short、unsigned short等，只要值能放进int就转为int，放不进int就放进unsigned int

- 宽字符（wchar_t、char16_t、char32_t）提升为int、unsigned int、long、unsigned long、long long、unsigned long long中能装进去的最小者



### 4.11.2-其他转换

- 数组转换为指针

- 转换成bool类型，0为false，非0为true
- 转换为常量：允许将指向非常量的指针或引用转为指向常量的指针或引用。但反之不可，底层const不可删除。
- 类类型的转换：类类型可定义转换，但编译器只能执行一步转换。



### 4.11-3-显式转换

也叫**强制类型转换**

- 显式转换形式为`cast-name<type>(expression)`，若type是引用类型，则返回`左值`。cast-name是`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`中的一种



**static_cast**

常用，只要不包含底层const，都可使用

```c++
double j = 3.14;
int i = static_cast<int> j; // i = 3
```



**const_cast**

只能改变对象的底层const



**reinterpret_cast**

为运算对象的位模式提供较低层次上的重新解释，即内存中的bits不变，改变解读方式。它依赖于机器，非常危险



**建议：避免使用强制类型转换**



## 4.12-运算符优先级

- `::`左结合律，全局作用域，用法 `::name`，在全局中查找