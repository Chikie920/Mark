## 基本内置类型



### 算数类型

基本和C差不多，C++提供了扩展字符集(貌似不常用)



### 带符号类型和无符号类型

signed与unsigned

与其他整型不同，字符型被分为三种:char、unsigned char、signed char



**如何选择类型**

一般整型用`int` 数据过大时用`long long`，因为`long`一般与`int`尺寸相同

浮点型用`double`  浮点值默认为`double`

### 类型转换

当我们把浮点数赋给整型时，小数部分会被截断

当我们赋给无符号整型一个超出范围的值时(如一个负数值)，结果为该值与这个无符号整型的范围的求模后的余数

当我们赋给有符号类型一个超出范围的值时，结果是未定义的



**不要在表达式内混用有符号与无符号的值**



## 变量

对C++程序员说 **变量** 与 **对象** 一般可以互换使用

通常情况下，对象指一块能储存数据并具有某种类型的内存空间



### 初始值

在C++中初始化和赋值是两个完全不同的操作

**初始化**的含义是在创建变量时赋予其一个初始值，**而赋值是把对象当前的值擦除用另一个代替**



### 列表初始化（C++11新标准）

```c++
int a = 0;
int a = {0};
int a{0};
int a(0);
//等效
```



### 默认初始化

定义在函数外部的变量默认初始化为0



### 变量声明和定义的关系

声明规定了变量的类型和名字，定义还申请储存空间，可可能为变量赋一个初始值

变量只能被定义一次，但是可以被多次声明



### 标识符

即变量名的定义

**和C一样不能使用关键字**

**不能连续使用两个下划线，不能以下划线接大写字母开头**

**函数体外的标识符不能以下划线开头**



### 变量作用域

**全局作用域**  -- 函数体外的变量

**块作用域** --  函数内的变量，循环内的变量



## 复合类型

C++有几种复合类型，这里介绍引用与指针



### 引用

```c++
int a = 1024;
int &b = a; //定义b指向a(相当于a的另一个名字)
std:: << b << std::endl;

//结果为1024
```

**引用在声明的同时必须被初始化**

 `int &b;`是错误的



**引用的类型与其绑定的对象相同，引用只能绑定在对象上，不能与表达式或字面值绑定**

**一旦定义了引用就无法使其再绑定另一个新的对象**

**引用不是对象，无地址**



### 指针

**建议初始化所有指针，未初始化就使用，指针会指向未知的对象**



指针是对象，允许对指针赋值和拷贝，指针无需在定义时赋值

`int *a`



**取地址符**

&

```c++
int *a;
int b = 0;
a = &b; //指针a存放了b的地址(指针指向了对象b)，当指向地址时，获取对象b的值
```



不能定义指向引用的指针，因为引用没有实际地址



**指针的类型与指向对象的类型要相同**



**解引用符**

*

得到指针所指对象的值

```C++
double a = 3.14;
double *p = &a;
std::cout << *p; //输出3.14
```



**空指针**

空指针不指向任何对象

几种声明空指针的方法

```c++
int *a = 0;
int *a = NULL; //NULL为预处理变量
int *a = nullptr; //字面值(c++11),推荐方法
```



**赋值与指针**

给指针赋值就是使其存放一个对象的地址

**指针**——储存——>**地址**——指向——>**对象**



**void*指针**

void*指针可以存放任意类型对象的地址

```c++
int a = 1;
double b = 1.2;
void *c = &a;
c = &b;
```



**复合类型的声明**

`int a = 1, *b = &a, &c = a`

他们都是`int`类型的对象



**指向指针的指针**

```c++
int ival = 1024;
int *pi = &ival;//指向ival的指针
int **ppi = &pi;//指向pi的指针

/*
ppi是指向ival的指针的指针
当我们两次解引用后即std::cout<<**ppi<<std::endl;得到ival的值即为1024
*/
```



**指向指针的引用**

```c++
int i = 42;
int *p = &i;//指向i的指针 
int *&r = p;//指向指针p的引用

r = &i;//等效于p = &il
*r = 0;//等效于*p = 0;即i等于0
```



### 理解复杂的类型

我们在看到一个类似`int *&r = p;`时或许有点懵

要理解r的类型是什么，我们可以**从左往右读**r的定义，**离变量名越近的符号对变量类型有直接的影响**



### `const`限定符

使用`const`创建常量，对象一经创建其值就无法再被改变，所以在声明的同时初始化

使用方法`const int a = 0;`和C一样



当我们想在一个文件内定义一个`const`常量，通过引入头文件而在多个文件中共享它时，

我们要不管声明还是定义都加上`extern`前缀(关键字)

如我们在file_1.cc文件中声明它，并在a.cc中使用

```c++
//file_1.cc
extern const int a = 0;
//a.cc
extern const int a;
```



**对`const`的引用**

对常量的引用不能更改对象的值

`const int &a = i;`(其中`i`为一个`int`类型的常数)

无法经行如 `a = 1024;`之类的操作



**指针与const**

和引用一样，无法改变常量



**const指针**

```c++
int a;
const int *p = a; //指针指向对象的值无法改变，但可以改变指针指向
int const *b = a; //同上
int * const c = a; //指针指向对象的值可以改变，但无法改变指针指向
const int * const d = a; //都无法改变
```



**顶层const与底层const**

前者指指针本身就是常量，后者指所指对象是常量



### 处理类型



**类型别名**

`typedef`与C的一样

**别名声明**

`using PI = int;`



**auto类型说明符**

`auto`让编译器自己根据初始值来确定变量类型

```c++
auto a = 0;
```



**decltype类型指示符**

```c++
int a = 0;
const int b = 1024;

decltype(a) c; //获得a的类型并返回，声明了一个int型的变量
decltype(b) d = 1024; //声明并初始化了一个const int型的常量

//括号内还可以是函数返回值或表达式
```

**对于decltype**

**decltype(变量) 另一个变量名; 只有一个括号时，表示声明一个该函数获得的类型的变量**

**decltype((变量名)) 另一个变量名 = 指向一个对象的名字;  当有两个括号时，表示声明一个引用，这时必须初始化**



### 自定义数据结构

其实这里就是C中的结构

使用`struct`声明



### 编写自己的头文件

类通常被定义在头文件中，头文件的名字应与类名相同



### 预处理器

`#define #undef #ifdef`

C中都介绍过

我们约定将常量名都大写





**作者：Chikie**  [Chikie920 · GitHub](https://github.com/Chikie920)

**Email: chikie920@foxmail.com or livewild0920@gmail.com**

**时间：2020/11/5**

**未经允许 禁止转载**