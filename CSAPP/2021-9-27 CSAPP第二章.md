# 第二章-信息的表示和处理



## 2.1-信息存储

最小可寻址单位：**字节**(byte)

**虚拟内存**：内存被抽象成的字节数组

**虚拟地址空间**：虚拟内存中每个字节地址的集合



### 2.1.1-十六进制表示法

`1 byte = 8 bits`，其值域为`0000 0000 ~ 1111 1111`

`1111 1111` = `1 0000 0000` - `1` = `2^7` - 1 = `256` - `1` = `255`

即值域为0~255



十六进制(hex) 范围为 1~9 A~F(字母不区分大小写) 即表示十进制的1~15

其中A-10 C-12 F-15

1个十六进制字符代表4个2进制位，因为一个二进制位能表示0或1，需要4个位才能表示一个十六进制符号(2^4 = 16)

十六进制的范围为0x00 ~ oxFF， 即0~255



![csapp_2_1](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_1.png)





**将二进制转十六进制**：二进制从右向左4个一组，最左边不够向前补零，再根据关系转换



- 十进制`2^n`转为二进制为1后跟n个零
- 十进制`2^n`转为十六进制，令`n = i+4*j` => `0x2^i`后跟`j`个零



### 2.1.2-字数据大小

**字长**：指针数据的标称大小(byte)

**虚拟地址的范围**：2^w(w为计算机的字长)



一个程序由编译方式不同分为32位和64位，32位程序能在32位和64位机器上运行，64位只能在64位机器上运行

![csapp_2_2](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_2.png)



### 2.1.3-寻址和字节顺序

对于一个int型变量(4字节)，值为十六进制数`0x1234567`，它的最高有效位为1，最低有效位为7

一个字节能表示两个十六进制位，如下为两种表示



![csapp_2_3](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_3.png)



**大端法：**最高有效字节在最前面

**小端法：**最低有效字节在最前面



### 2.1.9-C语言中的移位运算

对于一个w位的二进制数，向左移位`x << n`，其中二进制数x向左移动n位(n < w)，将前n位丢弃，在右端补n个零

移位运算是可结合的

右移运算分：**逻辑右移**和**算术右移**

**逻辑右移：**移动n位，丢弃后n位，左端补0

**算术右移：**移动n位，丢弃后n位，左端补最高位值

**对于无符号数，右移是逻辑的；对于有符号数，右移是算术的**



## 2.2-整数表示



### 2.2.2-无符号数的编码

例，对于4位二进制，B2U([1011]) = `1*2^3+0*2^2+1*2^1+1*2^0` = 11

w位能表示的无符号数的范围为[0000……0000] - [1111……1111] (括号内为w位)，即`0 - 2^w-1`



### 2.2.3-补码编码

与无符号不同的是，补码编码将最高有效位的权变为负值

例，对于4位二进制，B2U([1011]) = `1*（-2^3）+0*2^2+1*2^1+1*2^0` = -5

w位能表示的补码的范围为[1000……0000] - [0111……1111] (括号内为w位)，即`-2^(w-1) - 2^(w-1)-1`

**正数比负数少一个表示位，即最高位**



**计算机使用补码来表示整数**



#### 反码

除了最高有效位的权是`-2^(w-1)-1`而不是`-2^(w-1)`外和补码是一样的



#### 原码

最高有效位是符号位，用来确定剩下的位应该取负权还是正权

例，对于4位二进制，B2U([1011]) = （-`0*2^2+1*2^1+1*2^0`） = -3



**对于w位已知正数x补码求其相反数的补码**

-x的补码为`2^w` - x即[10000....00, n个零] - x，计算可得

**简便方法：**确定补码的符号位(最高位)为1，对于原码从右向左找到第一个表示1的位，其间的二进制位不变，从第一个1开始到最高位中间的所有位取反即得



例，对于4位二进制[0110] = 6，求-6的补码

确定最高位为1，原码[0110] 右到左第二位为1，到最高位中的0取反为1，得到[1010] = -8+2 = -6

等于[10000] - [0110] = [1010] = -6



### 2.2.4-有符号数和无符号数之间的转换



#### 补码转无符号数

- 正数的补码等于其无符号编码

- 负数的补码+`2^w`得到无符号编码



#### 无符号数转补码



### 2.2.6-扩展一个数字的位表示

当小数据类型准换为大类型时，其位会被扩展

扩展分两种：**零扩展**、**符号扩展**

**零扩展：**扩展的高位用零补满

**符号扩展：**扩展的高位用原最高位补满



与移位类似，无符号使用零扩展，有符号使用符号扩展



### 2.2.7-截断数字

当大数据类型准换为小类型时，其位会被截断



**截断无符号数**：将高位抛弃

**截断补码：**将高位抛弃，再用补码解释



### 2.2.8-关于有符号数与无符号数的建议

除了C 以外很少有语言支持无符号整数，但对系统程序员来说无符号类型很有用



## 2.3-整数运算



### 2.3.1-无符号加法

两个w位的无符号数，`0<=x, y<=2^w-1`相加得`0<=x+y<=2^(w+1)-2`，可能会需要`w+1`位表示，当超过位数时，需要将最高位舍去，即截断w位(`mod2^k`)

例：`1011`+`1001`=`10100`=`20mod2^4`=`4`=`0100`



如果`x+y<2^w`和的`w+1`位表示中的最高位会等于0, 因此丢弃它不会改变这个数值

如果`2^w<=x+y<2^(w+1)` 和的w+1 位表示中的最高位会等于1，因此丢弃它就相当于从和中减去了`2^w`



**算术运算溢出**：数据类型的位数放不下结果的表示



**无符号数加法**

`x+y=`

- `x+y`, `0<=x+y<2^w` 正常
- `x+y-2^w`, `2^w<=x+y` 溢出



**当执行C 程序时，不会将溢出作为错误而发信号**



**检测无符号数加法中的溢出**：当且仅当x与y的和小于其中一个数时发生了溢出



**无符号数求反**

对于`0<=x<2^w`

`-x=`

- x, x=0
- `2^w-x`, x>0

证:`2^w`-`x`+`x`=`2^w` +( -`x`+`x`)=`2^w` mod `2^w` = 0



### 2.3.2-补码加法

两个w位的无符号数，`2^w-1<=x, y<=2^(w-1)-1`相加得`-2^w<=x+y<=2^w-2`，可能会需要`w+1`位表示，当超过位数时需要将最高位舍去



**补码加法**

`x+y=`

- `x+y-2^w`, `2^(w-1)<=x+y` 正溢出

- `x+y`, `2^w-1<=x+y<2^(w-1)` 正常
- `x+y+2^w`, `x+y<-2^(w-1)` 负溢出

![csapp_2_4](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_4.png)



**检测补码加法中的溢出**

- 当且仅当两个正数相加，结果为负数，发生正溢出
- 当且仅当两个负数相加，结果为正数，发生负溢出



**求补码的相反数**

对一个补码，从右至左遇到第一个表示1的位不变，左边所有位取反



### 2.3.4-无符号乘法

两个w位的无符号数，`0<=x, y<=2^w-1`相乘得`(2^w-1)^2=2^2w-2^(w+1)-1`，可能会需要`2w`位表示，当超过位数时，保留`w`位

即:`x*y`=`x*ymod2^k`



### 2.3.5-补码乘法

与无符号数乘法位级表示相同(原理相同)，只不过对结果进行补码解释



### 2.3.6-乘以常数

以往，在大多数机器上，整数乘法指令相当慢，编译器使用移位和加法运算的组合来代替乘以常数因子的乘法

即将乘的数转化为一系列2的幂之和的形式



乘2的k次幂等于将该数二进制左移k位



**与2的幂相乘的无符号乘法**

0<=k<w

`x*2^k` = `x<<k`



由于整数乘法比移位和加法的代价要大得多，许多C 语言编译器试图以移位、加法和减法的组合来消除很多整数乘以常数的情况

例如，假设一个程序包含表达式x* 14。利用14 =23+22+21， 编译器会将乘法重写为（x<<3)+(x<<2) +(x<<1)将一个乘法替换为三
个移位和两个加法



### 2.3.7-除以2的幂

在大多数机器上，整数除法要比整数乘法更慢

整数除法总是舍入到零-**向零舍入**



**除以2 的幂的无符号除法**

向右移动`k`位, 0<=k<w

由于是无符号数，采用逻辑右移



**除以2的幂的补码除法，向下舍入**

对正数补码，与无符号数相同



**除以2的幂的补码除法，向上舍入**

对于负数补码

C 表达式`(x+(1<<k)-1)>>k`产生数值`x/2^k`(向上舍入)

低k位左边的位可能会加1，也可能不会加1。对于不需要舍人的情况(k=1)加上偏量只影响那些被移掉的位。对于需要舍人的情况，加上偏量导致较高的位加1，所以结果会向零舍人

![csapp_2_5](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_5.png)



### 2.3.8-关于整数运算的最后思考

计算机执行的“整数”运算实际上是一种模运算形式，补码表示提供了一种既能表示负数也能表示正数的灵活方法，同时使用了与执行无符号算术相同的位级实现，都有完全一样或者非常类似的位级行为



## 2.4-浮点数



### 2.4.1-二进制小数

数字权的定义与十进制小数点符号`.`相关



### 2.4.2-IEEE浮点表示

![csapp_2_6](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_6.png)

![csapp_2_7](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_7.png)

![csapp_2_8](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_8.png)



阶码的值为移码表示，需要减去一个**偏置(Bias)**`2^(w-1)-1`，对于单精度浮点数需要减去`2^7-1`即`127`



#### 规格化的值

阶码位不全为0或1，即阶码的表示范围为(对于单精度浮点数)`0000 0001` - `0111 1111`转换为指数为`-126` - `127`

小数字段为`0<=f<1`，尾数定义为M = 1+f，这个1是隐含的，我们不用显式表示它



#### 非规格化的值

阶码字段全为0，阶码值为`E=1-Bias`，尾数值为`f`，即小数字段值，不包含隐含的1

非规格化的值用来表示非常接近0的数(尾数不全为0)或0(尾数全为0)



#### 特殊值

阶码字段全为1，当尾数字段全为0时，表示无穷大或无穷小；当尾数字段不全为0时，表示不是一个数**NAN**



### 2.4.4-舍入

浮点运算是向偶数舍入

![csapp_2_9](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_9.png)



向上舍入得到的一组数的平均值将比这些数本身的平均值略高一些。向下舍入，那么舍人后的一组数的平均值将比这些数本身的平均值略低一些。向偶数舍人在大多数现实情况中避免了这种统计偏差



