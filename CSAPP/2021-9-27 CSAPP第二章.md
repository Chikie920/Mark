# 第二章-信息的表示和处理



## 2.1-信息存储

最小可寻址单位：**字节**(byte)

**虚拟内存**：内存被抽象成的字节数组

**虚拟地址空间**：虚拟内存中每个字节地址的集合



### 2.1.1-十六进制表示法

`1 byte = 8 bits`，其值域为`0000 0000 ~ 1111 1111`

`1111 1111` = `1 0000 0000` - `1` = `2^7` - 1 = `256` - `1` = `255`

即值域为0~255



十六进制(hex) 范围为 1~9 A~F(字母不区分大小写) 即表示十进制的1~15

其中A-10 C-12 F-15

1个十六进制字符代表4个2进制位，因为一个二进制位能表示0或1，需要4个位才能表示一个十六进制符号(2^4 = 16)

十六进制的范围为0x00 ~ oxFF， 即0~255



![csapp_2_1](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_1.png)





**将二进制转十六进制**：二进制从右向左4个一组，最左边不够向前补零，再根据关系转换



- 十进制`2^n`转为二进制为1后跟n个零
- 十进制`2^n`转为十六进制，令`n = i+4*j` => `0x2^i`后跟`j`个零



### 2.1.2-字数据大小

**字长**：指针数据的标称大小(byte)

**虚拟地址的范围**：2^w(w为计算机的字长)



一个程序由编译方式不同分为32位和64位，32位程序能在32位和64位机器上运行，64位只能在64位机器上运行

![csapp_2_2](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_2.png)



### 2.1.3-寻址和字节顺序

对于一个int型变量(4字节)，值为十六进制数`0x1234567`，它的最高有效位为1，最低有效位为7

一个字节能表示两个十六进制位，如下为两种表示



![csapp_2_3](C:\Users\Mirai\Desktop\Work\Mark\Sources\images\csapp_2_3.png)



**大端法：**最高有效字节在最前面

**小端法：**最低有效字节在最前面



### 2.1.9-C语言中的移位运算

对于一个w位的二进制数，向左移位`x << n`，其中二进制数x向左移动n位(n < w)，将前n位丢弃，在右端补n个零

移位运算是可结合的

右移运算分：**逻辑右移**和**算术右移**

**逻辑右移：**移动n位，丢弃后n位，左端补0

**算术右移：**移动n位，丢弃后n位，左端补最高位值

**对于无符号数，右移是逻辑的；对于有符号数，右移是算术的**



## 2.2-整数表示



### 2.2.2-无符号数的编码

例，对于4位二进制，B2U([1011]) = `1*2^3+0*2^2+1*2^1+1*2^0` = 11

w位能表示的无符号数的范围为[0000……0000] - [1111……1111] (括号内为w位)，即`0 - 2^w-1`



### 2.2.3-补码编码

与无符号不同的是，补码编码将最高有效位的权变为负值

例，对于4位二进制，B2U([1011]) = `1*（-2^3）+0*2^2+1*2^1+1*2^0` = -5

w位能表示的补码的范围为[1000……0000] - [0111……1111] (括号内为w位)，即`-2^(w-1) - 2^(w-1)-1`

**正数比负数少一个表示位，即最高位**



**计算机使用补码来表示整数**



#### 反码

除了最高有效位的权是`-2^(w-1)-1`而不是`-2^(w-1)`外和补码是一样的



#### 原码

最高有效位是符号位，用来确定剩下的位应该取负权还是正权

例，对于4位二进制，B2U([1011]) = （-`0*2^2+1*2^1+1*2^0`） = -3



**对于w位已知正数x补码求其相反数的补码**

-x的补码为`2^w` - x即[10000....00, n个零] - x，计算可得

**简便方法：**确定补码的符号位(最高位)为1，对于原码从右向左找到第一个表示1的位，其间的二进制位不变，从第一个1开始到最高位中间的所有位取反即得



例，对于4位二进制[0110] = 6，求-6的补码

确定最高位为1，原码[0110] 右到左第二位为1，到最高位中的0取反为1，得到[1010] = -8+2 = -6

等于[10000] - [0110] = [1010] = -6



### 2.2.4-有符号数和无符号数之间的转换



#### 补码转无符号数

- 正数的补码等于其无符号编码

- 负数的补码+`2^w`得到无符号编码



#### 无符号数转补码



### 2.2.6-扩展一个数字的位表示

当小数据类型准换为大类型时，其位会被扩展

扩展分两种：**零扩展**、**符号扩展**

**零扩展：**扩展的高位用零补满

**符号扩展：**扩展的高位用原最高位补满



与移位类似，无符号使用零扩展，有符号使用符号扩展



### 2.2.7-截断数字

当大数据类型准换为小类型时，其位会被截断



**截断无符号数**：将高位抛弃

**截断补码：**将高位抛弃，再用补码解释



### 2.2.8-关于有符号数与无符号数的建议

除了C 以外很少有语言支持无符号整数，尽量不要使用它