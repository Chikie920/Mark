## 最短路径



```c++
/*



注意：
使用matlab代码求解图论问题时，图的下标只能从1开始(正整数)
且当使用dijkstra算法时图的边的权值只能为正整数，而ford算法允许负权边但不允许负环



*/
```



### Dijkstra算法

基于贪心算法，得出源点到终点最短距离



#### 算法思路

需要二维数组保存图；dis数组保存起始节点到其他各点的距离，默认为INF；visit数组保存节点访问信息，默认为0；parent数组保存节点更新信息，默认为-1

从起始节点开始，将当前点作为中间节点，依次遍历得到当前点到其他未选节点的距离，将其加上dis[当前节点下标] => 得到源点到其他各未选节点的距离，若小于dis[该未选节点下标]（起始点经过当前点到该未选节点的距离），则更新dis数组与parent数组；遍历完各未选节点后，遍历dis数组中未选顶点，得到最小值对应的下标，将其visit对应值置为1，加入已选节点集合，并将其作为当前点再次进行上述操作。



#### matlab实现

使用`distance()`函数，未来或许会取代后者，也可使用`graphallshortestpaths()`函数

```matlab
clear;clc;
s = [1 1 1 2 2 3 4 4 5];
t = [2 3 5 4 5 2 3 1 4];
weight = [3 8 4 1 7 4 5 2 6];
names = {'A', 'B', 'C', 'D', 'E'};
G = digraph(s, t, weight, names); %生成图
% 无向图是graph 有向图是digraph
d = distances(G) %得到矩阵
plot(G, 'EdgeLabel', G.Edges.Weight)
distances(G, 1, 3, 'Method', 'positive')
%计算节点1到3的最短路径(Dijkstra)
```



#### c++实现

```c++
#include <iostream>
#include <string.h>

using namespace std;

const int MAX_SIZE = 20;
int route[MAX_SIZE][MAX_SIZE];
int visitd[MAX_SIZE];
int dis[MAX_SIZE];
int parent[MAX_SIZE];

/*


注意：
    输入矩阵时，当不存在边时，用-1代替


*/

int main()
{
    memset(route, 1, sizeof(route));
    memset(visitd, 0, sizeof(visitd));
    memset(dis, 1, sizeof(dis));
    memset(parent, -1, sizeof(parent));
    // 初始化集合

    int N;
    cout<<"输入节点个数:"<<endl;
    cin>>N;
    cout<<"输入图像矩阵:"<<endl;
    int temp;
    for(int i=0; i<N; ++i){
        for(int j=0; j<N; ++j){
            cin>>temp;
            if(temp == -1){
                continue;
            }
            route[i][j] = temp;
        }
    }
    // 输入矩阵

    int start;
    cout<<"输入起始点:"; // 注意：点编号从0开始
    cin>>start;

    visitd[start] = 1;
    dis[start] = 0;
    // 初始化起始点

    int pre = start;
    for(int i=0; i<N-1; ++i){
        for(int j=0; j<N; ++j){
            if(j==pre || visitd[j]){
                continue;
            }
            if(dis[pre]+route[pre][j] < dis[j]){
                dis[j] = dis[pre]+route[pre][j];
                parent[j] = pre;
            }
        } // 更新操作

        int max_v = 0x7FFFFFFF;
        int index;
        for(int i=0; i<N; ++i){
            if(visitd[i]){
                continue;
            }
            if(max_v > dis[i]){
                max_v = dis[i];
                index = i;
            }
        } // 搜索操作

        visitd[index] = 1;
        pre = index;
        // 添加操作
    }

    cout<<"距离向量: ";
    for(int i=0; i<N; ++i){
        cout<<dis[i]<<" ";
    }
    cout<<endl;

    cout<<"父节点向量: ";
    for(int i=0; i<N; ++i){
        cout<<parent[i]<<" ";
    }
    cout<<endl;

    return 0;
}

/*
测试矩阵

0 4 -1 -1 -1 -1 -1 8 -1
4 0 8 -1 -1 -1 -1 3 -1
-1 8 0 7 -1 4 -1 -1 2
-1 -1 7 0 9 14 -1 -1 -1
-1 -1 -1 9 0 10 -1 -1 -1
-1 -1 4 14 10 0 2 -1 -1
-1 -1 -1 -1 -1 2 0 6 6
8 3 -1 -1 -1 -1 6 0 1
-1 -1 2 -1 -1 -1 6 1 0

*/
```



### Floyd算法

基于动态规划算法，得出任意两点间最短距离



#### 算法思路

需要二维数组route保存图

该算法由三重循环构成，第一层循环为依次将各点作为中间点，第二层循环遍历其他各点经过中间点，第三层循环遍历中间点到其他各点

**优化**：

- 第二层与第三层可能重复即到中间点本身，则可以跳过
- 第一层与第二层可能重复，即中间点到其他各点，则可以跳过
- 第一层与第二层可能重复，即其他点到中间点，则可以跳过



#### matlab实现

可使用 `graphshortestpath()`或`shortestpath()`未来将取代前者

```matlab
s = [1 1 1 2 2 6 6 7 7 3 3 9 9 4 4 11 11 8];
t = [2 3 4 5 6 7 8 5 8 9 10 5 10 11 12 10 12 12];
weights = [10 10 10 10 10 1 1 1 1 1 1 1 1 1 1 1 1 1];
G = graph(s,t,weights);
plot(G,'EdgeLabel',G.Edges.Weight)
[P,d] = shortestpath(G,3,8) %返回路径节点与总长度
```



#### c++实现



```cpp
#include <iostream>
#include <string.h>


using namespace std;

const int MAX_SIZE = 20;
int route[MAX_SIZE][MAX_SIZE];

/*


注意：
    输入矩阵时，当不存在边时，用-1代替


*/

int main()
{
    memset(route, 1, sizeof(route));
    int N;
    cout<<"输入节点个数:"<<endl;
    cin>>N;
    cout<<"输入图像矩阵:"<<endl;
    int temp;
    for(int i=0; i<N; ++i){
        for(int j=0; j<N; ++j){
            cin>>temp;
            if(temp == -1){
                continue;
            }
            route[i][j] = temp;
        }
    }
    // 输入矩阵

    for(int i=0; i<N; ++i){ // 遍历次数或遍历各点或当前点
        for(int j=0; j<N; ++j){ // 其他各点到当前点
            for(int k=0; k<N; ++k){ // 当前点到其他各点
                if(i==j || j==k || i==k){
                    continue;
                } // 优化
                if(route[j][i]+route[i][k] < route[j][k]){
                    route[j][k] = route[j][i]+route[i][k];
                }
            }
        }
    }

    cout<<"结果为"<<endl;
    for(int i=0; i<N; ++i){
        for(int j=0; j<N; ++j){
            cout<<route[i][j]<<" ";
        }
        cout<<endl;
    }


    return 0;
}

/*
测试矩阵：
0 3 8 -1 -4
-1 0 -1 1 7
-1 4 0 -1 -1
2 -1 -5 0 -1
-1 -1 -1 6 0
*/

```



## 最小生成树



### Prim算法

基于贪心思想，与迪杰斯特拉算法类似



#### 算法思想

需要二维数组route储存图；dis数组储存边的权值；visit数组用于储存节点访问信息；parent数组用于存储边的节点信息

从起始点(0节点)开始，依次遍历与其相连的节点`i`，若边权值小于`dis[i]`则更新dis数组，且将`parent[i]`变为当前点下标，这里是0；

遍历完后，再遍历dis数组，得到最小权值的未选节点下标`j`，`visit[j]`置为1，将其作为当前点，继续重复上述操作。



#### matlab实现

可使用`minspantree()`或`graphminspantree()`后者将被取代

```matlab
clear;clc;
s = [1 1 1 2 2 3 4 4 5];
t = [2 3 5 4 5 2 3 1 4];
weight = [3 8 4 1 7 4 5 2 6];
G = graph(s, t, weight); %生成图
p = plot(G,'EdgeLabel',G.Edges.Weight);
[T,pred] = minspantree(G);
highlight(p,T) %高亮图像
```



#### c++实现

```cpp
#include <iostream>
#include <string.h>

using namespace std;

const int MAX_SIZE = 20;
int route[MAX_SIZE][MAX_SIZE];
int visitd[MAX_SIZE];
int dis[MAX_SIZE];
int parent[MAX_SIZE];

/*


注意：
    输入矩阵时，当不存在边时，用-1代替


*/


int main() 
{
    memset(route, 1, sizeof(route));
    memset(visitd, 0, sizeof(visitd));
    memset(dis, 1, sizeof(dis));
    memset(parent, -1, sizeof(parent));
    // 初始化集合

    int N;
    cout<<"输入节点个数:"<<endl;
    cin>>N;
    cout<<"输入图像矩阵:"<<endl;
    int temp;
    for(int i=0; i<N; ++i){
        for(int j=0; j<N; ++j){
            cin>>temp;
            if(temp == -1){
                continue;
            }
            route[i][j] = temp;
        }
    }
    // 输入矩阵

    int start = 0;
    visitd[start] = 1;
    dis[start] = 0;
    // 初始化起始点

    int pre = start;
    for(int i=0; i<N-1; ++i){
        for(int j=0; j<N; ++j){
            if(j==pre || visitd[j]){
                continue;
            }
            if(route[pre][j] < dis[j]){
                dis[j] = route[pre][j];
                parent[j] = pre;
            }
        } // 更新操作

        int max_v = 0x7FFFFFFF;
        int index;
        for(int i=0; i<N; ++i){
            if(visitd[i]){
                continue;
            }
            if(max_v > dis[i]){
                max_v = dis[i];
                index = i;
            }
        } // 搜索操作

        visitd[index] = 1;
        pre = index;
        // 添加操作
    }

    cout<<"距离向量: ";
    for(int i=0; i<N; ++i){
        cout<<dis[i]<<" ";
    }
    cout<<endl;

    cout<<"父节点向量: ";
    for(int i=0; i<N; ++i){
        cout<<parent[i]<<" ";
    }
    cout<<endl;

    return 0;
}

/*
测试矩阵:
0 4 -1 -1 -1 -1 -1 8 -1
4 0 8 -1 -1 -1 -1 11 -1
-1 8 0 7 -1 4 -1 -1 2
-1 -1 7 0 9 14 -1 -1 -1
-1 -1 -1 9 0 10 -1 -1 -1
-1 -1 4 14 10 0 2 -1 -1
-1 -1 -1 -1 -1 2 0 1 6
8 11 -1 -1 -1 -1 1 0 7
-1 -1 2 -1 -1 -1 6 7 0
*/
```



## 最大流

`maxflow()`函数

```matlab
clear;clc;
s = [1 1 2 2 3 4 4 4 5 5];
t = [2 3 3 4 5 3 5 6 4 6];
weights = [0.77 0.44 0.67 0.75 0.89 0.90 2 0.76 1 1];
G = digraph(s,t,weights);
[mf, gf] = maxflow(G, 1, 5) %mf为从源点1到终点5的最大流
```



## 最小费用最大流问题

详细内容参考附件

对弧`(v_i, v_j)`，用`f_ij`表示该弧流量，`w_ij`表示权重，`c_ij`表示容量，目的是


$$
min\sum_{v_i, v_j}w_{ij}*f_{ij}
$$






**思路**

1. 从零流开始，使用最短路径算法(迪杰斯特拉等)找出从发点到收点的一条最短路
2. 根据线路最大容量调整最短路(增广路)流量，更新路线图
3. 继续寻找最短路重复上述操作，直到找不到最短路线



## 指派问题

指派问题可以理解为运输问题



### 匈牙利解法



#### 产销平衡(标准形式)

例：人数与任务数相同的问题，且每人安排一个任务，下图为每个人完成每项任务需要的时间

<img src="D:\Chrome\xyl_1.jpg" alt="1" style="zoom: 80%;" />

**方法**

1. 矩阵`c`每行减去最小值得到`c'`；对`c'`每列减去最小值得到`c''`
2. 使用最少的线覆盖所有零元素，得出直线个数，若等于矩阵的行数(列数)则得到最优方案，跳到第四步；否则跳到第三步
3. 找出未被直线覆盖元素的最小元素 `θ` ，未被直线覆盖元素- `θ` ，直线交叉元素 + `θ` ，其他元素不变；操作完后返回第二步
4. 使用标号，标出n个(矩阵行列数或线数个数)位于不同行不同列的0元素，其他同行同列0元素需要划掉
5. 得到最优解矩阵，被标出的0元素位置全部置为1，其他位全部置为0，在原矩阵`c`中得到对应时间安排



<img src="D:\Chrome\xyl_2.jpg" alt="1" style="zoom: 80%;" />



<img src="D:\Chrome\xyl_3.jpg" alt="1" style="zoom: 80%;" />



<img src="D:\Chrome\xyl_4.jpg" alt="1" style="zoom: 80%;" />



<img src="D:\Chrome\xyl_5.jpg" alt="1" style="zoom: 80%;" />



#### 产销不平衡(非标准形式)



##### 人数不等于任务数

转化为标准型

- 人数<任务，增加虚拟人
- 人数>任务，增加虚拟任务

**例**

<img src="D:\Chrome\xyl_6.jpg" alt="1" style="zoom: 80%;" />



<img src="D:\Chrome\xyl_7.jpg" alt="1" style="zoom: 80%;" />



##### 最大模型

之前我们是希望花的时间越少越好，即元素值越小越好，而这里是希望元素值越大越好，如利润等

**解法**

得到矩阵最大元素值，用其减去矩阵中所有元素，得到新的矩阵，再使用标准解法



## TSP问题





## 论文写作
